#!/bin/python3

import os
from tempfile import TemporaryDirectory
import tomllib
import tomli_w
from packaging.version import Version
from collections import namedtuple
import argparse
from shutil import copytree

# Dependency = namedtuple('dep_info_t', ['name', 'comparison', 'version'])

root = ""

class Package:
	def __init__(self, name: str, version: Version, path: str):
		assert os.path.exists(path), "Package not found!"
		assert os.path.exists(path + "/pkg-info")
		self.name = name
		self.version = version
		self.path = path

	def get_info(self) -> dict:
		"""
		Reads and returns package metadata from a pkg-info file.

		This function asserts the existence of a package directory and its pkg-info file,
		then loads the metadata from the pkg-info file using the TOML format and returns
		it as a dictionary.

		:param path: The path to the package directory containing the pkg-info file.
		:return: A dictionary containing the package metadata.
		:raises AssertionError: If the package directory or pkg-info file does not exist.
		"""
		path = self.path
		assert os.path.exists(path), "Package not found!"
		assert os.path.exists(path + "/pkg-info")
		with open(path + "/pkg-info", "rb") as f:
			info = tomllib.load(f)
		return info

	def __repr__(self):
		return f"Pkg({self.name}, {self.version}, {self.path})"

class Dependency:
	def __init__(self, name: str, comparisons: list, versions: list):
		self.name = name
		self.comparisons = comparisons
		self.versions = versions

	def satisfied_by(self, version: Version) -> bool:
		for comparison, ver in zip(self.comparisons, self.versions):
			if comparison == "==":
				if version != Version(ver):
					return False
			elif comparison == ">=":
				if version < Version(ver):
					return False
			elif comparison == "<=":
				if version > Version(ver):
					return False
			elif comparison in [">", ">>"]:
				if version <= Version(ver):
					return False
			elif comparison in ["<", "<<"]:
				if version >= Version(ver):
					return False
		return True

	def parse(dep: str):
		"""
		Parses a dependency string and returns a dep_info_t representing the parsed dependency.

		The dep_info_t structure has the following fields:
			- name: The name of the package.
			- comparison: The comparison operator used in the dependency string.
			- version: The version of the package.

		For example, if given the input "pkg1 (>= 2.1.0)", the output will be:
			Dependency("pkg1", ">=", "2.1.0")
		"""
		if "(" in dep:
			name, constraint = dep.split("(", 1)
			name = name.rstrip().lstrip()
			constraint = constraint.strip(" )")
			comparisons = []
			versions = []
			for part in constraint.split(","):
				part = part.strip()
				comparison, version = part.split(" ", 1)
				comparisons.append(comparison)
				versions.append(version)
			return Dependency(name, comparisons, versions)
		else:
			return Dependency(dep, None, None)

def get_deb_info(path: str) -> dict:
	"""
	Extracts metadata from a .deb package.

	This function extracts all the metadata from a .deb package, and returns it as a dictionary.

	:raises ValueError: The package's control file is invalid.
	:raises FileNotFoundError: The package does not exist.
	"""
	assert os.path.exists(path), "Supplied path does not exist!"
	with TemporaryDirectory() as tmpdir:
		os.system(f"dpkg-deb -R {path} {tmpdir}")
		assert os.path.exists(tmpdir + "/DEBIAN/control"), "No control file found in package!"
		info_list = [] # contains tuples of (key: str, value: str)
		with open(tmpdir + "/DEBIAN/control") as control:
			file = control.read().rstrip()
			entry_list = file.split("\n")
			for entry in entry_list:
				if entry[0] == " " or entry[0] == "\t":
					if info_list:
						info_list[-1] = (info_list[-1][0], info_list[-1][1] + "\n"  + entry)
					else:
						raise ValueError("Invalid control file in package!")
				else:
					entry_split = entry.split(":")
					entry_split[1] = ''.join(entry_split[1:])

					key,value = entry_split[0:2]
					key = key.lstrip().rstrip()
					value = value.lstrip().rstrip()
					info_list.append((key, value))
	info = {}
	for entry_list in info_list:
		info[entry_list[0]] = entry_list[1]
	return info

def deb_to_pkg_info(info: dict) -> dict:
	"""
	Convert a debian control file info dict into a dalixOS pkg-info dict.

	This function takes a dict generated by get_deb_info and converts it into a dict
	that can be written to a pkg-info file.

	:raises ValueError: If the control file is invalid
	"""
	pkg_info = {
		"InfoType": 1,
		"Package": {}
	}
	try:
		pkg_info["Package"]["Name"] = info["Package"]
		pkg_info["Package"]["Version"] = info["Version"]
		pkg_info["Package"]["Arch"] = info["Architecture"]
		pkg_info["Package"]["Maintainer"] = info["Maintainer"]
		pkg_info["Package"]["Description"] = info["Description"]
		if "Depends" in info:
			deps = info["Depends"]
			# deps = deps.replace(",", "\n").replace("(", "").replace(")", "").replace(" ", "")
			pkg_info["Package"]["Dependencies"] = deps
		else:
			pkg_info["Package"]["Dependencies"] = ""
	except KeyError:
		raise ValueError("Invalid debian control file in package!")
	return pkg_info

def symlink(src: str, dst: str):
	"""
	Creates a symbolic link from src to dst. dst is what gets created.

	Ensures that the directory of dest exists before creating the symlink.
	"""
	os.makedirs(src, exist_ok=True)

	dst_dir = os.path.dirname(dst)
	os.makedirs(dst_dir, exist_ok=True)

	# relative_path = os.path.relpath(source_path, target_dir)
	os.symlink(src, dst, target_is_directory=os.path.isdir(src))


# path should point to a .deb file
def install_deb(path: str):
	"""
	Installs a .deb package into the system.

	This function will install a .deb package into the system. The package will be extracted and
	installed into a directory under /System/Packages, and the metadata will be extracted and stored
	in a file called pkg-info in the same directory.

	All symlinks will be created to point to the correct location.

	The system root will be changed to the newly installed package's chroot directory.

	:raises ValueError: The package's control file is invalid.
	:raises FileNotFoundError: The package does not exist.
	:raises AssertionError: The package's path does not end with .deb.
	"""
	global root

	assert os.path.exists(path), "Supplied path does not exist!"
	assert path.lower()[-4:] == ".deb", "Path does not point to a .deb file!"
	# create pkg directory
	with TemporaryDirectory() as tmpdir:
		# extract pkg
		os.system(f"dpkg -x {path} {tmpdir}")
		# extract metadata
		info = get_deb_info(path)
		info = deb_to_pkg_info(info)
		# install package

		inst_dir = f"{root}/System/Packages/{info["Package"]["Name"]}***{info["Package"]["Version"]}"

		if os.path.exists(inst_dir):
			os.system(f"rm -R {inst_dir}")
		os.system(f"mkdir -p {inst_dir}")

		# create symlinks
		chroot = inst_dir + "/chroot"
		symlink(f"{chroot}/usr/bin", f"{chroot}/bin")
		symlink(f"{chroot}/usr/bin", f"{chroot}/usr/local/bin")
		symlink(f"{chroot}/usr/sbin", f"{chroot}/sbin")
		symlink(f"{chroot}/usr/lib", f"{chroot}/lib")
		symlink(f"{chroot}/usr/lib64", f"{chroot}/lib64")
		symlink(f"{chroot}/usr/etc", f"{chroot}/etc")
		symlink(f"{chroot}/usr/var", f"{chroot}/var")

		# os.system(f"cp -Ra {tmpdir}/. {inst_dir}/chroot")
		copytree(
			tmpdir,
			f"{inst_dir}/chroot",
			symlinks=True,
			dirs_exist_ok=True
		)

		# install config
		os.system(f"touch {inst_dir}/pkg-info")
		with open(f"{inst_dir}/pkg-info", "w") as info_f:
			info_f.write(
				tomli_w.dumps(
					info,
					multiline_strings=True
				),
			)
		# install dependencies from debians servers.
		if "Dependencies" in info["Package"]:
			print(Package(info["Package"]["Name"], Version(info["Package"]["Version"]), inst_dir))
			fetch_deps(Package(info["Package"]["Name"], Version(info["Package"]["Version"]), inst_dir))

def fetch_deps(pkg: Package):
	"""
	Fetches the dependencies of a package from debian's servers.
	We make apt do the heavy lifting
	"""

	deps = []
	print(pkg)
	info = pkg.get_info()
	if not "Dependencies" in info["Package"]:
		return
	cmd = "apt satisfy --download-only"
	dep_string = info["Package"]["Dependencies"]
	with TemporaryDirectory() as tmpdir:
		os.system(f"{cmd} \"{dep_string}\" -o Dir::Cache::Archives={tmpdir}")
		deps = os.listdir(tmpdir)


def get_pkg_list():
	"""
	Yields a list of all packages in the system.
	"""
	packages = os.listdir(f"{root}/System/Packages")
	for pkg in packages:
		pkg_name = pkg.split("***")
		if len(pkg_name) != 2:
			print(f"Corrupt package in system! \"{pkg}\" Skipping for now.")
			continue
		pkg_ret = Package(
			pkg_name[0],
			Version(pkg_name[1]),
			f"{root}/System/Packages/{pkg}"
		)
		yield pkg_ret

def search_pkg_list(name: str, strict=False):
	"""
	Searches for packages in the system package list by name.

	This function iterates over the list of packages installed in the system
	and yields packages that match the given name. If `strict` is True,
	it yields packages with an exact name match. If `strict` is False,
	it yields packages that contain the given name as a substring.

	:param name: The name or substring to search for in package names.
	:param strict: A boolean indicating whether to perform a strict name match.
	:return: Yields dictionaries representing matched packages.
	"""
	global root

	for pkg in get_pkg_list():
		if strict:
			if pkg.name == name:
				yield pkg
		else:
			if name in pkg.name:
				yield pkg

def get_pkg(name: str):
	# We try to use the newest version availible to us.
	"""
	Returns the newest package matching the given name.

	This function iterates over the list of packages installed in the system
	and returns the newest package that matches the given name. If no packages
	match the given name, it returns None.

	:param name: The name of the package to search for.
	:return: A dictionary representing the newest package with a matching name.
	"""
	candidates = list(search_pkg_list(name))
	if not candidates: return None
	newest = None
	for candidate in candidates:
		if newest == None:
			newest = candidate
		else:
			if newest.version < candidate.version:
				newest = candidate
	return newest

def list_directory_tree(path: str) -> list:
	"""
	Returns a recursive list of all files and directories in the given path.

	:param path: The path to list the directory tree of.
	:return: A list of all files and directories (recursively) in the given path.
	"""
	files = []
	for root, dirs, filenames in os.walk(path):
		files.append(root)
		files.extend(os.path.join(root, f) for f in filenames)
	files.remove(path)
	return files




def get_deps_info(deps: list) -> list:
	"""
	Parses a list of dependencies and returns a
	list of dep_info_t representing the parsed dependencies.

	The dep_info_t structure has the following fields:
		- name: The name of the package.
		- comparison: The comparison operator used in the dependency string.
		- version: The version of the package.

	For example, if given the input ["pkg1 (>= 2.1.0)", "pkg2 (= 3.2.1)", "pkg3 (<= 4.3.2)", "pkg4"],
	the output will be:
	[
		dep_info_t("pkg1", [">="], ["2.1.0"]),
		dep_info_t("pkg2", ["="], ["3.2.1"]),
		dep_info_t("pkg3", ["<="], ["4.3.2"]),
		dep_info_t("pkg4", None, None)
	]
	"""
	deps_info = []
	for dep in deps:
		deps_info.append(Dependency.parse(dep))

	return deps_info

def deps_to_pkgs(deps_info: list) -> list:
	"""
	Takes a list of Dependency objects and returns a list of Package objects representing the newest version
	of each dependency that satisfies the dependency's comparison operators.

	For example, if given the input
	[
		Dependency("pkg1", [">="], ["2.1.0"]),
		Dependency("pkg2", ["="], ["3.2.1"]),
		Dependency("pkg3", ["<="], ["4.3.2"]),
		Dependency("pkg4", None, None)
	],
	the output will be a list of Package objects representing the newest version of each package that
	satisfies the given comparison operators.

	For example, if the newest version of "pkg1" is 2.2.0, the output would contain a Package object
 reprÃ©sentating the newest version of "pkg1" that satisfies ">=" 2.1.0, which is 2.2.0.

	:param deps_info: A list of Dependency objects.
	:return: A list of Package objects.
	"""
	pkg_deps = []

	for dep in deps_info:
		pkgs = list(search_pkg_list(dep.name, strict=True))
		if not pkgs:
			raise ValueError(f"Could not find dependency \"{dep.name}\"")

		best = pkgs[0]
		for pkg in pkgs:
			if pkg.version > best.version and dep.satisfied_by(pkg.version):
				best = pkg
		pkg_deps.append(best)

	return pkg_deps

def get_files_and_directories_from_deps(deps: list) -> list:
	class item_t:
		def __init__(self, bwrap_loc, fullpath, pkg, occurences):
			self.bwrap_loc = bwrap_loc
			self.fullpath = fullpath
			self.pkg = pkg
			self.occurences = occurences
		def __repr__(self):
			return f"Item({self.bwrap_loc}, {self.fullpath}, {self.pkg.name}, {self.occurences})"

	# generate trees of all of them, and merge them together
	directories = []
	files = []
	for dep in deps:
		# for each dependency...
		dep_root = os.path.join(dep.path, "chroot")
		dep_contents = list_directory_tree(dep_root)
		for dep_item in dep_contents:
			if os.path.isdir(dep_item):
				directories.append(item_t(
					dep_item[len(dep_root):], # removes down the common prefix
					dep_item,
					dep,
					None
				))
			elif os.path.isfile(dep_item):
				files.append(item_t(
					dep_item[len(dep_root):], # removes down the common prefix
					dep_item,
					dep,
					None
				))

	# So now we have a list of all the files and directories that need to be included
	# This list is massive but we must not panic...

	# files, and directories are all of type item_t
	# so we need to convert them to their bwrap location

	directories_bwrap_locations = [x.bwrap_loc for x in directories]
	files_bwrap_locations = [x.bwrap_loc for x in files]

	dirs_occ = occurence_count(directories_bwrap_locations)
	files_occ = occurence_count(files_bwrap_locations)

	for dir,occ in zip(directories, dirs_occ):
		dir.occurences = dirs_occ[occ]

	for file,occ in zip(files, files_occ):
		file.occurences = files_occ[occ]

	return files, directories

def occurence_count(l: list) -> dict:
	return {x: l.count(x) for x in l}


def generate_bwrap_args(deps: list) -> list:
	"""
	Generates a list of bubblewrap arguments for setting up the container environment.

	This function constructs bubblewrap arguments to set up the container with necessary
	overlays and bind mounts. The root of the system is mounted as an overlay for the source,
	and specific directories are bound to their respective locations.

	deps should be passed in a form of
	["pkg1==2.1.0", "pkg2>=3.2.1", "pkg3<=4.3.2"]

	:param deps: A list of dependencies required for the container.
	:return: A list of bubblewrap arguments for container setup.
	"""
	global root
	args = []
	args.append(f"--overlay-src {root}")
	args.append(f"--tmp-overlay /")
	args.append(f"--bind {root}/System /System")
	args.append(f"--bind {root}/Users /Users")
	args.append(f"--bind {root}/Volumes /Volumes")

	# generate list of packages that need to be included

	# Parse list of dependencies
	deps_info = get_deps_info(deps)

	# Get list of packages from list of dependencies
	deps = deps_to_pkgs(deps_info)

	# item_t = namedtuple('item_t', ['bwrap_loc', 'fullpath', 'pkg', "occurences"])

	# Get list of files and directories from list of dependencies
	files, directories = get_files_and_directories_from_deps(deps)

	# We need to follow the rules defined in Pkgs.md

	# for each directory...
	# if occurence count = 1, symlink
	# if occurence count > 1, create directory

	symlinked = []
	for dir in directories:
		if dir.occurences == 1:
			# Everything is mounted within / so we don't have to worry about root inside the
			# container. But outside of the container we do. therfore, src_path must be to
			# inside /System/Packages not {root}/System/Package.
			for sym in symlinked:
				if dir.bwrap_loc.startswith(sym):
					break
			else:
				src_path = dir.fullpath[len(root):]
				args.append(f"--symlink {dir.bwrap_loc} {src_path}")
				symlinked.append(dir.bwrap_loc)
		elif dir.occurences > 1:
			args.append(f"--mkdir {dir.bwrap_loc}")

	# for each file...
	# if occurence count = 1, symlink
	# if occurence count > 1, only the file closest to the main package will be symlinked

	for file in files:
		if True: # file.occurences == 1:
			# Everything is mounted within / so we don't have to worry about root inside the
			# container. But outside of the container we do. therfore, src_path must be to
			# inside /System/Packages not {root}/System/Package.
			for sym in symlinked:
				if file.bwrap_loc.startswith(sym):
					break
			else:
				src_path = file.fullpath[len(root):]
				args.append(f"--symlink {file.bwrap_loc} {src_path}")

	return args